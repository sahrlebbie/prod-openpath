#!/usr/bin/env python
from __future__ import absolute_import, division, print_function
# splunklib version is 1.6.3
import splunklib.client as client
from splunklib.modularinput import Argument, Script, Scheme, Event
import json
import sys
import dateutil.parser
import dateutil.tz
import requests
import re
from datetime import datetime, timedelta
if sys.version_info[0] < 3:
    import urllib
else:
    import urllib.parse as urllib

def _utcnow():
    """
    Helper method which allows us to mock datetime.utcnow() responses in our test suite.
    Datetime is written in C code and apparently can't be mocked as a result. Who knew?

    :return datetime:
    """
    return datetime.now(dateutil.tz.tzutc())


class PfptSiemScript(Script):
    APP = 'TA-Proofpoint-TAP'
    USERNAME = None
    MASK = '<encrypted>'
    CLEAR_PASSWORD = None
    PROXY_SERVER = None
    PROXY_PORT = None
    PROXY_USERNAME = None
    PROXY_PASSWORD = None
    SIEM_URL_PROTOCOL = 'https://'
    SIEM_URL_DEFAULT_HOST = 'tap-api-v2.proofpoint.com'
    SIEM_URL_PATH = '/v2/siem/all'
    SIEM_URL_QUERY_PARAMS = '?format=json&threatStatus=falsePositive&threatStatus=active&threatStatus=cleared'
    VALIDATE_SSL = True
    max_past = _utcnow() - timedelta(hours=11, minutes=59)
    collection_name = APP
    input_kv_key = None
    token = None
    nobody_client = None
    admin_client = None
    input_name = None
    ew = None

    # noinspection PyArgumentEqualDefault
    def get_scheme(self):
        """
        Returns a ``Scheme`` object which is used to define new inputs

        :return Scheme: the modular input's scheme
        """

        scheme = Scheme('Proofpoint TAP SIEM Modular Input')
        scheme.description = 'Modular Input which pulls data from the Proofpoint SIEM API'
        name_arg = Argument(name='name',
                            title='Name',
                            description='The name of the Splunk input stanza.',
                            data_type=Argument.data_type_string,
                            required_on_create=True,
                            required_on_edit=True)
        scheme.add_argument(name_arg)
        username_arg = Argument(name='username',
                                title='Principal',
                                description='The service principal generated by the Threat Insight Dashboard.',
                                data_type=Argument.data_type_string,
                                required_on_create=True,
                                required_on_edit=True)
        scheme.add_argument(username_arg)
        password_arg = Argument(name='password',
                                title='Secret',
                                description='The secret generated by the Threat Insight Dashboard.',
                                data_type=Argument.data_type_string,
                                required_on_create=True,
                                required_on_edit=True)
        scheme.add_argument(password_arg)
        proxy_server_arg = Argument(name='proxy_server',
                                    title='HTTPS Proxy Hostname',
                                    description='(Optional) Hostname of the proxy that the Splunk server uses '
                                                'to connect to the internet.',
                                    data_type=Argument.data_type_string,
                                    required_on_create=False,
                                    required_on_edit=False)
        scheme.add_argument(proxy_server_arg)
        proxy_port_arg = Argument(name='proxy_port',
                                  title='HTTPS Proxy Port',
                                  description='(Optional) The port number of the proxy. Defaults to 443.',
                                  data_type=Argument.data_type_number,
                                  required_on_create=False,
                                  required_on_edit=False)
        scheme.add_argument(proxy_port_arg)
        proxy_username_arg = Argument(name='proxy_username',
                                      title='Proxy Username',
                                      description='(Optional) The username used to connect to the proxy.',
                                      data_type=Argument.data_type_string,
                                      required_on_create=False,
                                      required_on_edit=False)
        scheme.add_argument(proxy_username_arg)
        proxy_password_arg = Argument(name='proxy_password',
                                      title='Proxy Password',
                                      description='(Optional) The password used to authenticate to the proxy.',
                                      data_type=Argument.data_type_string,
                                      required_on_create=False,
                                      required_on_edit=False)
        scheme.add_argument(proxy_password_arg)
        siem_url_host_arg = Argument(name='siem_url_host',
                                      title='SIEM URL Host',
                                      description='(DO NOT CHANGE) The location of the Proofpoint TAP SIEM service',
                                      data_type=Argument.data_type_string,
                                      required_on_create=True,
                                      required_on_edit=True)
        scheme.add_argument(siem_url_host_arg)
        return scheme

    def encrypt_password(self, username, password):
        """
        Saves a cleartext password into Splunk's secure password storage service

        :param str username: the username associated with the password
        :param str password: the cleartext password to encrypt
        :raise Exception: if any issue is encountered while communicating with the storage passwords service
        """
        try:
            for storage_password in self.admin_client.storage_passwords:
                if storage_password.username == username:
                    self.admin_client.storage_passwords.delete(
                            username=storage_password.username)
                    break
            self.admin_client.storage_passwords.create(password, username)
        except Exception as e:
            raise Exception(
                    "{}: An error occurred updating credentials. Please ensure your user account has admin_all_objects"
                    " and/or list_storage_passwords capabilities. Details: {}".format(self.input_name, e))

    def mask_password(self, location):
        """
        Replaces a password configuration item with a masked version and re-saves the input definition

        :param str location:  the location of the password configuration item
        :raise Exception: if any error is encountered while saving inputs.conf
        """
        unsupported_keys = ['disabled', 'host_resolved']
        try:
            kind, input_name = self.input_name.split('://')
            for input_def in self.admin_client.inputs.list(kind):
                if input_def.name != input_name:
                    continue
                new_input_content = input_def.content.copy()
                new_input_content[location] = self.MASK
                for key in unsupported_keys:
                    if key in new_input_content:
                        del new_input_content[key]
                new_input = input_def.update(**new_input_content)
                new_input.refresh()
                break
        except Exception as e:
            raise Exception('{}: Error updating inputs.conf: {}'.format(self.input_name, e))

    def get_password(self, username):
        """
        Retrieves the cleartext password from Splunk's password storage service

        :param str username: the username corresponding to the password we want to retrieve
        :return str: the cleartext password
        :raise ValueError: if the username is not found in the password storage service
        """
        for storage_password in self.admin_client.storage_passwords:
            if storage_password.username == username:
                return storage_password.content.clear_password
        raise ValueError('{}: get_password/Could not find user record for {} in storage_passwords'.format(self.input_name, username))

    def set_authentication_information(self, items):
        """
        Sets all the information required to authenticate, based on the input definition. If the input definition's
        passwords are not masked, it encrypts and masks them. Usually, this would only be done the first time the
        input definition is run after it is created.

        :param dict items: a dictionary containing input definition configuration
        """

        password = items['password']
        proxy_password = items.get('proxy_password', None)
        self.USERNAME = items['username']
        self.PROXY_SERVER = items.get('proxy_server', None)
        self.PROXY_PORT = items.get('proxy_port', None)
        self.PROXY_USERNAME = items.get('proxy_username', None)
        self.SIEM_URL_HOST = items.get('siem_url_host', self.SIEM_URL_DEFAULT_HOST)
        self.set_siem_url()
        kind, input_name = self.input_name.split('://')
        proxy_password_storage_key = '_'.join([kind, input_name, str(self.PROXY_USERNAME)])
        if password != self.MASK:
            self.encrypt_password(self.USERNAME, password)
            self.mask_password('password')
        self.CLEAR_PASSWORD = self.get_password(self.USERNAME)
        if proxy_password:
            if proxy_password != self.MASK:
                # So that we don't accidentally stomp on any other input's stored
                # passwords, we'll prepend the "username" with the kind and
                # input_name and use that to store the password.
                self.encrypt_password(proxy_password_storage_key, proxy_password)
                self.mask_password('proxy_password')
            self.PROXY_PASSWORD = self.get_password(proxy_password_storage_key)

    def set_siem_url(self):
        """
        builds the appropriate URL and turns on or off SSL validation, based on settings,

        :return None:
        """
        self.VALIDATE_SSL = True if (self.SIEM_URL_HOST is self.SIEM_URL_DEFAULT_HOST) else False
        self.SIEM_URL = self.SIEM_URL_PROTOCOL + self.SIEM_URL_HOST + self.SIEM_URL_PATH + self.SIEM_URL_QUERY_PARAMS

    def get_headers(self):
        """
        called when building the SIEM request, to set version information in the request header

        :return dict: contains the User-Agent string to user
        """
        ta_version = self.admin_client.apps[self.APP]['version']
        ta_user_agent = '{}/{}'.format(self.APP, ta_version)
        return {'User-Agent': ta_user_agent}

    def validate_input(self, definition):
        """
        called by Splunk to validate that the user-supplied input is correct

        :param splunklib.modularinput.InputDefinition definition: the input definition being validated
        :raise ValueError: if the status code returned by the SIEM API does not indicate success
        """
        # We may need to set the token admin_client here as well, since validation happens in a separate
        # invocation of the script that doesn't go through the stream_events method, and we use
        # the get_password method here.
        if self.admin_client is None:
            self.token = definition.metadata['session_key']
            self.admin_client = client.connect(token=self.token, autologin=True)
        username = definition.parameters['username']
        password = definition.parameters['password']
        proxy_username = definition.parameters.get('proxy_username', None)
        proxy_password = definition.parameters.get('proxy_password', None)
        self.SIEM_URL_HOST = definition.parameters.get('siem_url_host', self.SIEM_URL_DEFAULT_HOST)
        self.set_siem_url()
        now = (_utcnow() - timedelta(hours=1)).isoformat()
        url = self.SIEM_URL + '&{}'.format(urllib.urlencode({'sinceTime': now}))
        if password == self.MASK:
            password = self.get_password(username)
        if proxy_password == self.MASK:
            kind = definition.parameters['sourcetype']
            input_name = definition.metadata['name']
            proxy_password_storage_key = '_'.join([kind, input_name, str(proxy_username)])
            proxy_password = self.get_password(proxy_password_storage_key)
        auth = (username, password)
        proxies = self.get_proxies(
                definition.parameters.get('proxy_server', None),
                definition.parameters.get('proxy_port', None),
                proxy_username,
                proxy_password)
        headers = self.get_headers()
        resp = requests.get(url, auth=auth, proxies=proxies, headers=headers, verify=self.VALIDATE_SSL)
        if resp.status_code not in (200, 204):
            raise ValueError('{}: validate_input/Could not access TAP SIEM using provided credentials.'.format(self.input_name))

    def retrieve_last_poll_time(self):
        """
        Returns the last successful poll time from the Splunk KV store

        :return datetime: either the last poll time or the maximum time into the past which can be successfully queried
        """
        kv = self.nobody_client.kvstore[self.collection_name]
        query_args = {'query': '{{"input_name":"{}"}}'.format(self.input_name)}
        results = kv.data.query(**query_args)
        if len(results) == 0:
            return self.retrieve_old_poll_time()
        if len(results) > 1:
            raise ValueError(
                    'retrieve_last_poll_time/When trying to retrieve the last poll time, '
                    'multiple kvstore records were found which match {}'.format(self.input_name))
        self.input_kv_key = results[0]['_key']
        last_poll_time_s = results[0]['last_poll_time']
        last_poll_time_dt = dateutil.parser.parse(last_poll_time_s)
        if last_poll_time_dt < self.max_past:
            self.ew.log(self.ew.INFO, 'retrieve_last_poll_time/Previous poll time is too far in the past.'
                                      ' Returning maximum data available.')
            return self.max_past
        return last_poll_time_dt

    def retrieve_old_poll_time(self):
        """
        Older versions of the script stored the last poll time inside the collection schema, instead of the
        actual kv data store. Try to find the old poll value and delete the old collection, if found.

        :return datetime: either the last poll time or the maximum time into the past which can be successfully queried
        """

        import time
        if sys.version_info[0] < 3:
            import md5
            credhash = md5.new(self.USERNAME).hexdigest()
        else:
            import hashlib
            credhash = hashlib.md5(self.USERNAME).hexdigest()

        field_name = 'field.{}'.format(credhash)
        old_collection_name = 'proofpoint_tap_siem'
        try:
            collection = self.nobody_client.kvstore[old_collection_name]
            last_poll_time_s = collection[field_name]
            last_poll_time_dt = dateutil.parser.parse(last_poll_time_s)
            if last_poll_time_dt.tzinfo is None:
                # The first statement attaches the local timezone to the naive date. The second converts to UTC.
                last_poll_time_dt = last_poll_time_dt.replace(tzinfo=dateutil.tz.tzoffset('', time.timezone * -1))
                last_poll_time_dt = last_poll_time_dt.astimezone(dateutil.tz.tzutc())
            collection.delete()
            if last_poll_time_dt < self.max_past:
                self.ew.log(self.ew.INFO, '{}: retrieve_last_poll_time/Previous poll time is too far in the past.'
                                          ' Returning maximum data available.'.format(self.input_name))
                return self.max_past
            return last_poll_time_dt
        except Exception as e:
            self.ew.log(self.ew.INFO, '{}: retrieve_last_poll_time/No previous poll results found: "{}"'
                                      ' Retrieving maximum data available.'.format(self.input_name, e))
            return self.max_past

    def update_last_poll_time(self, last_poll_time):
        """
        Updates the last successful poll time in the Splunk KV store.

        :param str last_poll_time: A string containing the last successful poll time
        """
        data = json.dumps({'input_name': self.input_name, 'last_poll_time': last_poll_time})
        kv = self.nobody_client.kvstore[self.collection_name]
        if self.input_kv_key is None:
            result = kv.data.insert(data)
            self.input_kv_key = result['_key']
        else:
            kv.data.update(self.input_kv_key, data)

    def query_and_save(self, start_time_s, end_time_s):
        """
        Performs a single request to the TAP SIEM API, using any configured proxy. After a successful query, it updates
        the last successful poll time.

        :param datetime start_time_s: the start of the query interval (inclusive)
        :param datetime end_time_s: the end of the query interval (exclusive)
        """
        args = urllib.urlencode({'interval': '{}/{}'.format(start_time_s, end_time_s)})
        url = '{}&{}'.format(self.SIEM_URL, args)
        try:
            auth = (self.USERNAME, self.CLEAR_PASSWORD)
            proxies = self.get_proxies(self.PROXY_SERVER, self.PROXY_PORT, self.PROXY_USERNAME, self.PROXY_PASSWORD)
            headers = self.get_headers()
            resp = requests.get(url, auth=auth, proxies=proxies, headers=headers, verify=self.VALIDATE_SSL)
            if resp.status_code == 204:
                self.ew.log(self.ew.INFO, '{}: query_and_save/Empty content returned from {} to {}'.format(self.input_name, start_time_s, end_time_s))
            elif resp.status_code != 200:
                self.ew.log(self.ew.ERROR, '{}: query_and_save/Querying from {} to {}, but SIEM server returned: {} {}'
                            .format(self.input_name, start_time_s, end_time_s, resp.status_code, resp.reason))
                return
            self.ew.log(self.ew.INFO, '{}: query_and_save/Successful query from {} to {}'.format(self.input_name, start_time_s, end_time_s))
            self.save_events(resp.json())
            self.update_last_poll_time(last_poll_time=end_time_s)
        except Exception as e:
            self.ew.log(self.ew.ERROR, '{}: query_and_save/Could not query TAP URL- {} ({})'.format(self.input_name, url, e))
            sys.exit(1)

    def save_events(self, data):
        """
        Processes a single content query's return value. Adds the eventType attribute to each event before logging it.

        :param dict data: a dictionary containing events to be logged
        """
        # Python's default isoformat uses +00:00 instead of Z, so replace it for consistency.
        default_event_time = re.sub('(?<=[0-9]{3})([0-9]{3})?\+00:00', 'Z', _utcnow().isoformat())
        for key in data.keys():
            if key in ['clicksBlocked', 'clicksPermitted', 'messagesBlocked',
                       'messagesDelivered']:
                evdata = data[key]
                for row in evdata:
                    if 'eventType' not in row:
                        row.update({'eventType': key})
                    if 'eventTime' not in row:
                        row.update({'eventTime': default_event_time})
                    event = Event()
                    event.stanza = self.input_name
                    event.data = json.dumps(row)
                    self.ew.write_event(event)

    def stream_events(self, inputs, ew):
        """
        The main procedure which is invoked by Splunk to initiate event download.

        :param splunklib.modularinput.InputDefinition inputs: an InputDefinition sourced from Splunk
        :param splunklib.modularinput.EventWriter ew: an EventWriter object which will be used to log events
        :return:
        """
        self.token = inputs.metadata['session_key']
        self.nobody_client = client.connect(token=self.token, owner='nobody', app=self.APP, autologin=True)
        self.admin_client = client.connect(token=self.token, autologin=True)
        self.ew = ew

        for full_input_name, items in inputs.inputs.items():
            self.input_name = full_input_name
            try:
                self.set_authentication_information(items)
                self.download_intervals()
            except Exception as e:
                self.ew.log(self.ew.ERROR, '{}: stream_events/{}'.format(self.input_name, e))
                continue

    def download_intervals(self):
        """
        Sequentially initiates downloads of SIEM logs in tranches of one hour at a time.

        :return: None
        :raise ValueError: if the interval is too long, too short, or if the end is before the start
        """
        initial_time_dt = self.retrieve_last_poll_time()
        final_time_dt = _utcnow()

        if final_time_dt <= initial_time_dt:
            raise ValueError('{}: download_intervals/End of interval must be after start of interval'.format(self.input_name))
        if (final_time_dt - initial_time_dt) > timedelta(hours=12):
            raise ValueError('{}: download_intervals/Interval cannot be greater than 12 hours'.format(self.input_name))
        hours, seconds = divmod(
                int((final_time_dt - initial_time_dt).total_seconds()), 3600)

        for hour in range(hours):
            start_secs_offset = (3600 * hour) + 1
            start_time_dt = initial_time_dt + timedelta(seconds=start_secs_offset)
            start_time_s = self.fmtdate(start_time_dt)
            end_secs_offset = start_secs_offset + 3599
            end_time_dt = initial_time_dt + timedelta(seconds=end_secs_offset)
            end_time_s = self.fmtdate(end_time_dt)
            self.query_and_save(start_time_s, end_time_s)
        # This is cheating, but if we have exactly one second left over, we'll end up having the same
        # start and end times, which the SIEM service will throw an error on. So, we'll tack on an
        # extra second, why not?
        if seconds > 0:
            if seconds == 1:
                seconds = 2
            start_secs_offset = (3600 * hours) + 1
            start_time_dt = initial_time_dt + timedelta(seconds=start_secs_offset)
            start_time_s = self.fmtdate(start_time_dt)
            end_secs_offset = start_secs_offset + seconds - 1
            end_time_dt = initial_time_dt + timedelta(seconds=end_secs_offset)
            end_time_s = self.fmtdate(end_time_dt)
            # The previous cheat should make this exception unreachable, but I'll leave it here for
            # when we solve the problem which makes the cheat necessary.
            if start_time_s == end_time_s:
                raise ValueError('{}: download_intervals/Cannot download a single second.'.format(self.input_name))
            self.query_and_save(start_time_s, end_time_s)

    @staticmethod
    def fmtdate(ts):
        """
        Utility method to return UTC timestamps in ISO8601 format.

        :param ts datetime: a ``datetime`` object
        :return str: a string containing the ISO8601 formatted time in UTC
        """
        return ts.strftime('%Y-%m-%dT%H:%M:%SZ')

    # noinspection PyMethodMayBeStatic
    def get_proxies(self, proxy_server=None, proxy_port=None, proxy_username=None, proxy_password=None):
        auth = ''
        port = ''
        if proxy_server is None:
            return {}
        if proxy_username is not None:
            auth = urllib.quote(proxy_username)
        if proxy_password is not None and auth != '':
            auth += ':' + urllib.quote(proxy_password)
        if auth != '':
            auth += '@'
        if proxy_port is not None:
            port = ':' + str(proxy_port)
        return {'https': 'https://' + auth + proxy_server + port}


if __name__ == '__main__':
    exitcode = PfptSiemScript().run(sys.argv)
    sys.exit(exitcode)
